<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nuget on SystemOut</title>
    <link>http://localhost:1313/tags/nuget/</link>
    <description>Recent content in Nuget on SystemOut</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>nmj@systemout.net (Nicklas Møller Jepsen)</managingEditor>
    <webMaster>nmj@systemout.net (Nicklas Møller Jepsen)</webMaster>
    <lastBuildDate>Thu, 01 Oct 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/nuget/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Async RSS Parser Service</title>
      <link>http://localhost:1313/2015/10/01/async-rss-parser-service/</link>
      <pubDate>Thu, 01 Oct 2015 00:00:00 +0000</pubDate>
      <author>nmj@systemout.net (Nicklas Møller Jepsen)</author>
      <guid>http://localhost:1313/2015/10/01/async-rss-parser-service/</guid>
      <description>

&lt;h2 id=&#34;introduction:cd8934bb510e397ca8b305f3943838bf&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This post is about how you can implement a generic RSS parser that runs as a service, meaning that it keeps parsing the given URLs in a loop. The reason behind this is that I wanted to be able to data mine some of the daily news from the press and therefore I needed to store the articles in my own database.&lt;/p&gt;

&lt;p&gt;The result is a Nuget package that can be included in a .NET project:
&lt;code&gt;Install-Package SystemOut.RssParser&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you just want to check out the source for the project, then go to &lt;a href=&#34;https://github.com/nicklasjepsen/SystemOut.RssService&#34;&gt;Github where I host the repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you want to know how I implemented the code, then please read on!&lt;/p&gt;

&lt;h2 id=&#34;rss-parser-implementation:cd8934bb510e397ca8b305f3943838bf&#34;&gt;RSS Parser Implementation&lt;/h2&gt;

&lt;p&gt;The project consists of several classes; several RSS model base classes that represents the XML model of a RSS feed.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at some typical RSS XML&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;rss&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;version=&amp;quot;2.0&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;channel&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;link&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;language&amp;gt;&amp;lt;/language&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;item&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;link&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
  			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;pubDate&amp;gt;&amp;lt;/pubDate&amp;gt;&lt;/span&gt;
  			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;comments&amp;gt;&amp;lt;/comments&amp;gt;&lt;/span&gt;
  			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;guid&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;isPermaLink=&amp;quot;false&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;gt;&amp;lt;/guid&amp;gt;&lt;/span&gt;
  			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;enclosure&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;url=&amp;quot;&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;type=&amp;quot;image/jpeg&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;length=&amp;quot;3930&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;/channel&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;/rss&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;To be able to deserialize this feed we have some classes: BaseRssFeed.cs, BaseRssChannel.cs and BaseRssItem.cs. Those classes are just plain old C# classes with properties - not that intereseting - you can find them &lt;a href=&#34;https://github.com/nicklasjepsen/SystemOut.RssService&#34;&gt;on Github&lt;/a&gt; if you want to.&lt;/p&gt;

&lt;p&gt;The RssDeserializer.cs is more interesting - here is the GetFeed method:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;static&lt;/span&gt; T GetFeed&amp;lt;T&amp;gt;(&lt;span style=&#34;color: #902000&#34;&gt;string&lt;/span&gt; feedUrl)
{
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;string&lt;/span&gt;.IsNullOrEmpty(feedUrl)) &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;default&lt;/span&gt;(T);
	
	&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; xs = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; XmlSerializer(&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;typeof&lt;/span&gt;(T));
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;try&lt;/span&gt;
	{
		&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; xmlReaderSettings = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; XmlReaderSettings
		{
			DtdProcessing = DtdProcessing.Parse
		};
		T rss;
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; reader = XmlReader.Create(feedUrl, xmlReaderSettings))
		{
			rss = (T)xs.Deserialize(reader);
		}
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; rss;
	}
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;catch&lt;/span&gt; (WebException webException)
	{
		Logger.Log(LogLevel.Error, webException);
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;default&lt;/span&gt;(T);
	}
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;catch&lt;/span&gt; (InvalidOperationException invalidOperationException)
	{
		Logger.Log(LogLevel.Error, invalidOperationException);
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;default&lt;/span&gt;(T);
	}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;As you can see, we are using the XmlSerializer and XmlReader to read and deserialize the RSS feed. Not much magic, because we get most by using the built in implementations of .NET.&lt;/p&gt;

&lt;p&gt;Now to be able to be able to use the deserializer generically we have a wrapper around the RssDeserializer:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;FeedItem&amp;gt;&amp;gt; Parse(FeedSource source)
{
    &lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; feed = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;await&lt;/span&gt; Task.Run(() =&amp;gt; RssDeserializer.GetFeed(source.Url));
    &lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; channel = feed?.GetRssChannels()?.FirstOrDefault();
    &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (channel == &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;null&lt;/span&gt;)
        &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; List&amp;lt;FeedItem&amp;gt;();
    &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;from&lt;/span&gt; rssItem &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;in&lt;/span&gt; channel.GetRssItems()
            &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; FeedItem
            {
                Title = rssItem.Title,
                Url = rssItem.Link,
                ExternalItemId = rssItem.GetGuid(),
                ImportTime = DateTime.UtcNow,
                PublishTime = rssItem.Date,
                FeedSource = source,
                Summary = rssItem.Description,
            }).ToList();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;This method calls the deserializers parse method and transforms the objects into the desired feed items.&lt;/p&gt;

&lt;p&gt;Now to the most intereseting part - the RSS Parsing Service.
The class &lt;strong&gt;NewsFeedParseService.cs&lt;/strong&gt; is designed with custom events that will be triggered once a new RSS feed item is imported. This is done so that the caller can determine what to do with the new item. First I had an Entity Framework context in the NewsFeedParserService but when I wanted to publish the solution as a Nuget package I needed to extract the database logic from the parsing. Therefore I decided to create an event based service that notifies the caller when a new item is imported. This moves the responsibility of data persistance away from the parser and out where it belongs.
For the above reason we have the following event i the NewsFeedParseService.cs:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;delegate&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;NewFeedItemHandler&lt;/span&gt;(&lt;span style=&#34;color: #902000&#34;&gt;object&lt;/span&gt; sender, FeedItemEventArgs e);
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;event&lt;/span&gt; NewFeedItemHandler OnNewFeedItems;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;This event is triggered in the Execute method that async runs until cancelled:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;async&lt;/span&gt; Task &lt;span style=&#34;color: #06287e&#34;&gt;Execute&lt;/span&gt;(CancellationToken cancellationToken)
{
	&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; feedItemsCache = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span style=&#34;color: #902000&#34;&gt;string&lt;/span&gt;&amp;gt;();
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;do&lt;/span&gt;
	{
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; feedSource &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;in&lt;/span&gt; feedSources)
		{
			Logger.Debug(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Reading feed from {feedSource.Url}.&amp;quot;&lt;/span&gt;);
			&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; newItems = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; List&amp;lt;FeedItem&amp;gt;();
			&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; items = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;await&lt;/span&gt; defaultParser.Parse(feedSource);
			&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (items == &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;null&lt;/span&gt;)
				&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;continue&lt;/span&gt;;
		
			&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; feedItem &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;in&lt;/span&gt; items)
			{
				&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (feedItemsCache.Contains(feedItem.ExternalItemId))
					&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;continue&lt;/span&gt;;
				feedItemsCache.Add(feedItem.ExternalItemId);
				newItems.Add(feedItem);
			}
		
			Logger.Debug(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Got {newItems.Count} new items.&amp;quot;&lt;/span&gt;);
		
			&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (newItems.Count &amp;gt; &lt;span style=&#34;color: #40a070&#34;&gt;0&lt;/span&gt;)
				OnNewFeedItems?.Invoke(&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; FeedItemEventArgs { Items = newItems });
		
		}
		
		Logger.Info(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Sleeping {ConfigurationProvider.GetIntValue(ConfigurationProvider.FeedImportIntervalInSeconds, 60)} second(s) before starting all over.&amp;quot;&lt;/span&gt;);
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;await&lt;/span&gt; Task.Delay(ConfigurationProvider.GetIntValue(ConfigurationProvider.FeedImportIntervalInSeconds, &lt;span style=&#34;color: #40a070&#34;&gt;60&lt;/span&gt;) * &lt;span style=&#34;color: #40a070&#34;&gt;1000&lt;/span&gt;, cancellationToken);
	} &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;while&lt;/span&gt; (!cancellationToken.IsCancellationRequested);

	Logger.Info(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Task is cancelled - escaping endless loop.&amp;quot;&lt;/span&gt;);  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;What happens here is that we are creating a HashSet using this a a cache for already imported feeditems. Because RSS parsing is poll based we need to import the manually and prevent the clients from getting multiple events for the same items.
Further more we are calling the parse operation and then iterating all the results and if they do not exist in the cache, we trigger a new event, notifying the caller that a new item is imported.
This goes on in a loop that only gets escaped if the caller decides to cancel the execution.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s pretty much it! Next post will be about how to use SignalR to push the new post to clients so we can create a web site that dynamically updates when a new post is added.&lt;/p&gt;

&lt;p&gt;Remember to check out the &lt;a href=&#34;https://www.nuget.org/packages/SystemOut.RssParser/&#34;&gt;Nuget site for the project&lt;/a&gt; or simply install it directly in you projects:
&lt;code&gt;Install-Package SystemOut.RssParser&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Also check out &lt;a href=&#34;https://github.com/nicklasjepsen/SystemOut.RssService&#34;&gt;the Github repo&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gravatar C# API</title>
      <link>http://localhost:1313/2015/08/08/gravatar-csharp-api/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      <author>nmj@systemout.net (Nicklas Møller Jepsen)</author>
      <guid>http://localhost:1313/2015/08/08/gravatar-csharp-api/</guid>
      <description>&lt;p&gt;Each time I write a new app that involves users (which is pretty often) I think it would be nice to be able to display their own profile image, without the need of authenticating them against facebook, Linkedin or by using their Microsoft account.&lt;/p&gt;

&lt;p&gt;Therefore I decided to use Gravatar, which basically allows you to request a user image (avatar) when you only know their email address. This is pretty simply and you can just make a plain HTTP GET and get their image url in response. Try this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://gravatar.com/avatar/f561d9206d313b49f9bde3bd50803b84&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t want to read any more and just want the Nuget package:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Install-Package GravatarSharp.Core&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now, there is now email address in this request, and that is because Gravatar uses a hash of the users email. So you would need some way of generating the hash from the users email and then making the request.
Further more you can retrieve lots of other information about the users presented in JSON format:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://en.gravatar.com/nicklasjepsen.json]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Because I write many applications that could use this, and because I love small APIs/libraries I decided to make a Gravatar C# API and put the code on Github and make the API distributable using Nuget.&lt;/p&gt;

&lt;p&gt;You can find the project here &lt;a href=&#34;https://github.com/nicklasjepsen/GravatarSharp&#34;&gt;on Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And on Nuget: &lt;a href=&#34;https://www.nuget.org/packages/GravatarSharp.Core&#34;&gt;GravatarSharp.Core&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you just need to install the Nuget package for a project, simply open the package manager and enter:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Install-Package GravatarSharp.Core&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>