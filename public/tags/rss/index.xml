<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rss on SystemOut</title>
    <link>http://systemout.net/tags/rss/</link>
    <description>Recent content in Rss on SystemOut</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>nmj@systemout.net (Nicklas Møller Jepsen)</managingEditor>
    <webMaster>nmj@systemout.net (Nicklas Møller Jepsen)</webMaster>
    <lastBuildDate>Thu, 01 Oct 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://systemout.net/tags/rss/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Async RSS Parser Service</title>
      <link>http://systemout.net/2015/10/01/async-rss-parser-service/</link>
      <pubDate>Thu, 01 Oct 2015 00:00:00 +0000</pubDate>
      <author>nmj@systemout.net (Nicklas Møller Jepsen)</author>
      <guid>http://systemout.net/2015/10/01/async-rss-parser-service/</guid>
      <description>

&lt;h2 id=&#34;introduction:cd8934bb510e397ca8b305f3943838bf&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This post is about how you can implement a generic RSS parser that runs as a service, meaning that it keeps parsing the given URLs in a loop. The reason behind this is that I wanted to be able to data mine some of the daily news from the press and therefore I needed to store the articles in my own database.&lt;/p&gt;

&lt;p&gt;The result is a Nuget package that can be included in a .NET project:
&lt;code&gt;Install-Package SystemOut.RssParser&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If you just want to check out the source for the project, then go to &lt;a href=&#34;https://github.com/nicklasjepsen/SystemOut.RssService&#34;&gt;Github where I host the repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you want to know how I implemented the code, then please read on!&lt;/p&gt;

&lt;h2 id=&#34;rss-parser-implementation:cd8934bb510e397ca8b305f3943838bf&#34;&gt;RSS Parser Implementation&lt;/h2&gt;

&lt;p&gt;The project consists of several classes; several RSS model base classes that represents the XML model of a RSS feed.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at some typical RSS XML&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;rss&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;version=&amp;quot;2.0&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;channel&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;link&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;language&amp;gt;&amp;lt;/language&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;item&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;link&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;description&amp;gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
  			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;pubDate&amp;gt;&amp;lt;/pubDate&amp;gt;&lt;/span&gt;
  			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;comments&amp;gt;&amp;lt;/comments&amp;gt;&lt;/span&gt;
  			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;guid&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;isPermaLink=&amp;quot;false&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;gt;&amp;lt;/guid&amp;gt;&lt;/span&gt;
  			&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;enclosure&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;url=&amp;quot;&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;type=&amp;quot;image/jpeg&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #4070a0&#34;&gt;length=&amp;quot;3930&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;/item&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;/channel&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color: #062873; font-weight: bold&#34;&gt;&amp;lt;/rss&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;To be able to deserialize this feed we have some classes: BaseRssFeed.cs, BaseRssChannel.cs and BaseRssItem.cs. Those classes are just plain old C# classes with properties - not that intereseting - you can find them &lt;a href=&#34;https://github.com/nicklasjepsen/SystemOut.RssService&#34;&gt;on Github&lt;/a&gt; if you want to.&lt;/p&gt;

&lt;p&gt;The RssDeserializer.cs is more interesting - here is the GetFeed method:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;static&lt;/span&gt; T GetFeed&amp;lt;T&amp;gt;(&lt;span style=&#34;color: #902000&#34;&gt;string&lt;/span&gt; feedUrl)
{
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;string&lt;/span&gt;.IsNullOrEmpty(feedUrl)) &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;default&lt;/span&gt;(T);
	
	&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; xs = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; XmlSerializer(&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;typeof&lt;/span&gt;(T));
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;try&lt;/span&gt;
	{
		&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; xmlReaderSettings = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; XmlReaderSettings
		{
			DtdProcessing = DtdProcessing.Parse
		};
		T rss;
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; reader = XmlReader.Create(feedUrl, xmlReaderSettings))
		{
			rss = (T)xs.Deserialize(reader);
		}
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; rss;
	}
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;catch&lt;/span&gt; (WebException webException)
	{
		Logger.Log(LogLevel.Error, webException);
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;default&lt;/span&gt;(T);
	}
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;catch&lt;/span&gt; (InvalidOperationException invalidOperationException)
	{
		Logger.Log(LogLevel.Error, invalidOperationException);
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;default&lt;/span&gt;(T);
	}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;As you can see, we are using the XmlSerializer and XmlReader to read and deserialize the RSS feed. Not much magic, because we get most by using the built in implementations of .NET.&lt;/p&gt;

&lt;p&gt;Now to be able to be able to use the deserializer generically we have a wrapper around the RssDeserializer:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;FeedItem&amp;gt;&amp;gt; Parse(FeedSource source)
{
    &lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; feed = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;await&lt;/span&gt; Task.Run(() =&amp;gt; RssDeserializer.GetFeed(source.Url));
    &lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; channel = feed?.GetRssChannels()?.FirstOrDefault();
    &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (channel == &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;null&lt;/span&gt;)
        &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; List&amp;lt;FeedItem&amp;gt;();
    &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;from&lt;/span&gt; rssItem &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;in&lt;/span&gt; channel.GetRssItems()
            &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; FeedItem
            {
                Title = rssItem.Title,
                Url = rssItem.Link,
                ExternalItemId = rssItem.GetGuid(),
                ImportTime = DateTime.UtcNow,
                PublishTime = rssItem.Date,
                FeedSource = source,
                Summary = rssItem.Description,
            }).ToList();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;This method calls the deserializers parse method and transforms the objects into the desired feed items.&lt;/p&gt;

&lt;p&gt;Now to the most intereseting part - the RSS Parsing Service.
The class &lt;strong&gt;NewsFeedParseService.cs&lt;/strong&gt; is designed with custom events that will be triggered once a new RSS feed item is imported. This is done so that the caller can determine what to do with the new item. First I had an Entity Framework context in the NewsFeedParserService but when I wanted to publish the solution as a Nuget package I needed to extract the database logic from the parsing. Therefore I decided to create an event based service that notifies the caller when a new item is imported. This moves the responsibility of data persistance away from the parser and out where it belongs.
For the above reason we have the following event i the NewsFeedParseService.cs:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;delegate&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;NewFeedItemHandler&lt;/span&gt;(&lt;span style=&#34;color: #902000&#34;&gt;object&lt;/span&gt; sender, FeedItemEventArgs e);
&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;event&lt;/span&gt; NewFeedItemHandler OnNewFeedItems;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;This event is triggered in the Execute method that async runs until cancelled:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;async&lt;/span&gt; Task &lt;span style=&#34;color: #06287e&#34;&gt;Execute&lt;/span&gt;(CancellationToken cancellationToken)
{
	&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; feedItemsCache = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span style=&#34;color: #902000&#34;&gt;string&lt;/span&gt;&amp;gt;();
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;do&lt;/span&gt;
	{
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; feedSource &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;in&lt;/span&gt; feedSources)
		{
			Logger.Debug(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Reading feed from {feedSource.Url}.&amp;quot;&lt;/span&gt;);
			&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; newItems = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; List&amp;lt;FeedItem&amp;gt;();
			&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; items = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;await&lt;/span&gt; defaultParser.Parse(feedSource);
			&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (items == &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;null&lt;/span&gt;)
				&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;continue&lt;/span&gt;;
		
			&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; feedItem &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;in&lt;/span&gt; items)
			{
				&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (feedItemsCache.Contains(feedItem.ExternalItemId))
					&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;continue&lt;/span&gt;;
				feedItemsCache.Add(feedItem.ExternalItemId);
				newItems.Add(feedItem);
			}
		
			Logger.Debug(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Got {newItems.Count} new items.&amp;quot;&lt;/span&gt;);
		
			&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (newItems.Count &amp;gt; &lt;span style=&#34;color: #40a070&#34;&gt;0&lt;/span&gt;)
				OnNewFeedItems?.Invoke(&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; FeedItemEventArgs { Items = newItems });
		
		}
		
		Logger.Info(&lt;span style=&#34;border: 1px solid #FF0000&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Sleeping {ConfigurationProvider.GetIntValue(ConfigurationProvider.FeedImportIntervalInSeconds, 60)} second(s) before starting all over.&amp;quot;&lt;/span&gt;);
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;await&lt;/span&gt; Task.Delay(ConfigurationProvider.GetIntValue(ConfigurationProvider.FeedImportIntervalInSeconds, &lt;span style=&#34;color: #40a070&#34;&gt;60&lt;/span&gt;) * &lt;span style=&#34;color: #40a070&#34;&gt;1000&lt;/span&gt;, cancellationToken);
	} &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;while&lt;/span&gt; (!cancellationToken.IsCancellationRequested);

	Logger.Info(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Task is cancelled - escaping endless loop.&amp;quot;&lt;/span&gt;);  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;What happens here is that we are creating a HashSet using this a a cache for already imported feeditems. Because RSS parsing is poll based we need to import the manually and prevent the clients from getting multiple events for the same items.
Further more we are calling the parse operation and then iterating all the results and if they do not exist in the cache, we trigger a new event, notifying the caller that a new item is imported.
This goes on in a loop that only gets escaped if the caller decides to cancel the execution.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s pretty much it! Next post will be about how to use SignalR to push the new post to clients so we can create a web site that dynamically updates when a new post is added.&lt;/p&gt;

&lt;p&gt;Remember to check out the &lt;a href=&#34;https://www.nuget.org/packages/SystemOut.RssParser/&#34;&gt;Nuget site for the project&lt;/a&gt; or simply install it directly in you projects:
&lt;code&gt;Install-Package SystemOut.RssParser&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Also check out &lt;a href=&#34;https://github.com/nicklasjepsen/SystemOut.RssService&#34;&gt;the Github repo&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Windows Phone RSS Reader</title>
      <link>http://systemout.net/2011/12/10/windows-phone-rss-reader/</link>
      <pubDate>Sat, 10 Dec 2011 00:00:00 +0000</pubDate>
      <author>nmj@systemout.net (Nicklas Møller Jepsen)</author>
      <guid>http://systemout.net/2011/12/10/windows-phone-rss-reader/</guid>
      <description>

&lt;p&gt;As part of a competition to win a Windows Phone I have created 3 WP7 apps. One of these is a RSS reader made specific for the danish it news site &lt;a title=&#34;Version2&#34; href=&#34;http://www.version2.dk&#34; target=&#34;_blank&#34;&gt;Version2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The source for this application can be found on&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://version2viewer.codeplex.com/&#34; target=&#34;_blank&#34;&gt;Codeplex&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The app is based on the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ff941098(v=vs.92).aspx&#34; target=&#34;_blank&#34;&gt;Pivot control&lt;/a&gt; in WP7. In short this means that you have a page with a list of feed items. On the same page there is a &amp;#8216;tab&amp;#8217; to another page where another feed&amp;#8217;s items are visible:&lt;/p&gt;

&lt;p style=&#34;text-align:center;&#34;&gt;
  &lt;a href=&#34;http://systemout.net/wp-content/uploads/2011/12/v2-screen1.png&#34;&gt;&lt;img class=&#34; wp-image-53 aligncenter&#34; title=&#34;V2-screen1&#34; src=&#34;http://systemout.net/wp-content/uploads/2011/12/v2-screen1.png&#34; alt=&#34;&#34; width=&#34;241&#34; height=&#34;438&#34; /&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;h2 id=&#34;the-view:feba98f87e7da1dc9b77288a18b111e7&#34;&gt;The View&lt;/h2&gt;

&lt;p&gt;The view is XAML code and is implemented using the &lt;a href=&#34;http://en.wikipedia.org/wiki/Model_View_ViewModel&#34; target=&#34;_blank&#34;&gt;MVVM&lt;/a&gt; pattern. This pattern is extremely powerful when it comes to binding data to the view. Furthermore DataTemplates are used to reuse the layout of the feed items.&lt;/p&gt;

&lt;p&gt;Here is an example of a DataTemplate:&lt;/p&gt;

&lt;pre class=&#34;brush: xml; title: ; notranslate&#34; title=&#34;&#34;&gt;&amp;lt;DataTemplate x:Name=&#34;FeedItemTemplate&#34;&amp;gt;
         &amp;lt;StackPanel Orientation=&#34;Vertical&#34;&amp;gt;
             &amp;lt;TextBlock Text=&#34;{Binding TruncatedTitle}&#34; 
                        TextWrapping=&#34;Wrap&#34; 
                        Margin=&#34;12,0,0,0&#34; 
                        Style=&#34;{StaticResource PhoneTextTitle3Style}&#34;/&amp;gt;
             &amp;lt;StackPanel Orientation=&#34;Horizontal&#34; 
                         Margin=&#34;0,0,0,17&#34;&amp;gt;
                 &amp;lt;TextBlock Text=&#34;{Binding TimeStamp}&#34; 
                            Foreground=&#34;#B0D011&#34; 
                            Margin=&#34;12,-6,0,0&#34; 
                            Style=&#34;{StaticResource PhoneTextSubtleStyle}&#34; /&amp;gt;
                 &amp;lt;TextBlock Text=&#34;{Binding Url}&#34;  
                            TextWrapping=&#34;NoWrap&#34; 
                            Margin=&#34;12,-6,0,0&#34; 
                            Style=&#34;{StaticResource PhoneTextSubtleStyle}&#34;/&amp;gt;
             &amp;lt;/StackPanel&amp;gt;
         &amp;lt;/StackPanel&amp;gt;
&amp;lt;/DataTemplate&amp;gt;
&lt;/pre&gt;

&lt;p&gt;This DataTemplate is then used in the ListBox ItemTemplate by using the FeedItemTemplate name:&lt;/p&gt;

&lt;pre class=&#34;brush: xml; title: ; notranslate&#34; title=&#34;&#34;&gt;&amp;lt;ListBox x:Name=&#34;NewsLbx&#34;
         Margin=&#34;0,0,-12,0&#34;
         ItemTemplate=&#34;{StaticResource FeedItemTemplate}&#34;
         ItemsSource=&#34;{Binding NewsItems}&#34;
         Tap=&#34;NewsLbx_Tap&#34;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;This is more or less the only thing required for the view to work. Remember the complete source is available at Codeplex, link at the top of this post.&lt;/p&gt;

&lt;h2 id=&#34;the-viewmodel:feba98f87e7da1dc9b77288a18b111e7&#34;&gt;The ViewModel&lt;/h2&gt;

&lt;p&gt;Now if you&amp;#8217;re wondering where the view is actually getting it&amp;#8217;s data from, then read on!&lt;/p&gt;

&lt;p&gt;In the project there is class, MainViewModel, this class is responsible of holding the data that the view uses and in this class has the ObservableCollections that contains the data.&lt;/p&gt;

&lt;p&gt;The view is bound to the data in the App.xaml.cs:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;	
		&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;static&lt;/span&gt; MainViewModel viewModel = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;null&lt;/span&gt;;

        &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;static&lt;/span&gt; MainViewModel ViewModel
        {
            &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;get&lt;/span&gt;
            {
                &lt;span style=&#34;color: #60a0b0; font-style: italic&#34;&gt;// Delay creation of the view model until necessary&lt;/span&gt;
                &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (viewModel == &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;null&lt;/span&gt;)
                    viewModel = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; MainViewModel();

                &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; viewModel;
            }
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The ItemViewModel is pretty straight forward; the class is implementing the INotifyPropertyChanged which makes the View auto updated when the data in the model is changed. To implement this the following is done:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;	
	&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #0e84b5; font-weight: bold&#34;&gt;FeedItemViewModel&lt;/span&gt; : INotifyPropertyChanged
	{
        &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;string&lt;/span&gt; title;
        &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color: #902000&#34;&gt;string&lt;/span&gt; Title
        {
            &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;get&lt;/span&gt; { &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;return&lt;/span&gt; title; }
            &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;set&lt;/span&gt;
            {
                &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;value&lt;/span&gt; != title)
                {
                    title = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;value&lt;/span&gt;;
                    NotifyPropertyChanged(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;Title&amp;quot;&lt;/span&gt;);
                }
            }
        }

        ...
	}
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The most noticeable thing in the above is the call to NotifyPropertyChanged(&amp;#8220;Title&amp;#8221;) &amp;#8211; this is to make the the view aware that a property has changed.&lt;/p&gt;

&lt;h2 id=&#34;the-rss-consumer:feba98f87e7da1dc9b77288a18b111e7&#34;&gt;The RSS Consumer&lt;/h2&gt;

&lt;p&gt;To retrieve the  RSS data a WebClient is used:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;	
	WebClient web = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; WebClient();
    web.DownloadStringCompleted += &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; DownloadStringCompletedEventHandler(WebClient_DownloadStringCompleted);
    web.DownloadStringAsync(uri);
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;When the download is completed the following are executed:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f0f0f0&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;	
	StringReader sr = &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; StringReader(e.Result);
    &lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; reader = XmlReader.Create(sr);
    &lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; document = XDocument.Load(reader);

    &lt;span style=&#34;color: #902000&#34;&gt;var&lt;/span&gt; entries =
                 &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;from&lt;/span&gt; entry &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;in&lt;/span&gt; document.Descendants(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;channel&amp;quot;&lt;/span&gt;).Descendants(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;item&amp;quot;&lt;/span&gt;)
                 let title = entry.Element(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;title&amp;quot;&lt;/span&gt;).Value
                 let link = entry.Element(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;comments&amp;quot;&lt;/span&gt;).Value
                 let pubDate = entry.Element(&lt;span style=&#34;color: #4070a0&#34;&gt;&amp;quot;pubDate&amp;quot;&lt;/span&gt;).Value
                 &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color: #007020; font-weight: bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color: #06287e&#34;&gt;FeedItemViewModel&lt;/span&gt;()
                 {
                     Title = title,
                     Url = link,
                     PubDate = DateTime.Parse(pubDate)
                 };
    feedHandler(entries.ToArray());
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;By using LINQ the response from the RSS feed is handled and parsed into the FeedItemViewModel. This could probably be made a hole lot prettier, but hey; it&amp;#8217;s open source and yours to edit on Codeplex.&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s pretty much it!&lt;/p&gt;

&lt;p&gt;If you have any comments/suggestions/questions, then please contact me :)&lt;/p&gt;

&lt;div style=&#34;font-size:0px;height:0px;line-height:0px;margin:0;padding:0;clear:both&#34;&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>